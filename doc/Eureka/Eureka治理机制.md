### 服务调用

所谓服务调用，就是一个服务调用另外一个服务的过程。要解释Eureka作为服务治理中心的服务调用过程，需要讨论其基础架构的3个重要概念

#### 服务治理中心

指Eureka服务器，，在http 请求重使用FUND代替了服务器名称（或者地址）和端口。之所以可以这样，是因为FUND这个名称是在Eureka服务治理中心注册的微服务名称，它下面存在7001和7002两个端口微服务实例，所以可以轮询选择其中一个。这便是服务治理中心的作用之一。此外，服务治理中心还会提供服务注册、失败剔除、服务续约和服务下线等功能，用来治理各个微服务实例

#### 服务提供者

在微服务系统中，服务提供者主要是以REST风格的端点被服务消费者调用的，而服务提供者是注册在Eureka中的，所以Eureka可以对其进行治理

#### 服务消费者

解析的过程是，首先根据这个名称从服务治理中心获取服务提供者的实例列表，保存在本地，然后通过特定的负载均衡的策略确定具体的实例，最后通过请求该实例获取数据。可以使用了Ribbon和OpenFeign来实现服务消费

这里的服务提供者和消费者并不是对立的，一个微服务可以同时是服务消费者和服务提供者，从这个角度来说，服务提供者和消费者都是Eureka服务治理中心的客户端

### 服务治理中心工作原理

#### 微服务实例和服务治理中心的关系

任何的微服务都可以对Eureka服务治理中心（也称为Eureka服务端）发送REST风格的请求。在Eureka的机制中，一般是由具体的微服务（也称为Eureka客户端）来主动维持它们之间的关系的。Eureka客户端的请求类型包括注册、续约和下线，下面将对它们展开讨论

- 注册

  在将具体的微服务实例注册到Eureka服务端时，是通过REST风格请求其配置的属性eureka.client.serviceUrl.defaultZone生成的URL来完成的，这时，微服务会将其自身的信息传递给Eureka服务端，完成注册。配置项spring.application.name，是作为微服务名称来定义的，这样可以明确该实例归属于哪个微服务

  在微服务实例中，存在一个配置项eureka.client.register-with-eureka，它的值是布尔（boolean）类型的，默认为true，代表默认情况下将微服务注册到Eureka服务治理中心。当我们将其配置为false的时候，微服务不会被注册到Eureka服务端。注意，当启动微服务时，它并不会马上向Eureka服务治理中心发送REST请求，在Eureka服务治理中心注册，它会延迟40秒才发起请求，所以在启动微服务的时候，需要稍等一会儿才能在Eureka服务治理中心页面中看到注册信息

- 续约

  在我们将具体的微服务实例注册到Eureka服务端后，并不能保证该实例一直可用，因为该实例可能出现网络故障、机器故障或者服务宕机等，所以具体的微服务实例会按照一个频率对Eureka服务器维持心跳，告诉Eureka该实例是可用的，借此来避免被Eureka服务端剔除出去，这样的行为被称为续约（Renew）。在续约的过程中，存在两个配置项，它们是： （由注册服务中心配置）

  ```yaml
  eureka:
    instance:
      # 微服务实例超时失效秒数，默认为90 秒 倘若续约超时，Eureka 会将微服务实例剔除
      lease-expiration-duration-in-seconds: 90
      # 间隔对应的秒数执行一次续约服务  默认为30 秒
      lease-renewal-interval-in-seconds: 30
  ```

  这样，Eureka就可以通过续约服务来确认，对应的微服务实例是否还能正常工作了，对于不能正常工作的实例，也能够及时剔除了

- 下线
  在系统出现故障，需要停止或者重启某个微服务实例的时候，在正常操作下，实例会对Eureka发送下线REST风格请求，告知服务治理中心，这样客户端就不能再请求这个实例了

#### 服务治理中心

通过注册、续约和下线3种服务，Eureka可以有效地管理具体的微服务实例。但是服务治理中心之间和本身也会提供一定的服务，甚至可以说服务治理中心也是Eureka客户端，因为它也可以注册到其他的Eureka服务器中，被其他的Eureka服务器治理。这一节我们来了解一下Eureka

- 相互复制

  Eureka本身也会相互注册，以保证高可用和高性能。各个Eureka服务器之间也会相互复制，也就是当微服务发生注册、下线和续约这些操作的时候，Eureka会将这些消息转发到其他服务治理中心的实例上，这样就完成同步了。需要注意的是，这里的Eureka服务器之间采用的是对等模式（Peer-to-Peer），也就是每一个Eureka都是等价的，这有别于分布式中的主从模式（Master-Slave）

- 服务剔除

  在实际的工作中，有时候有些服务会因为网络故障、内存溢出或者宕机而导致服务不能正常工作，这个时候就要将这些无效的服务实例剔除出去。Eureka Server在启动时，会创建一个定时任务，在默认的情况下，每间隔60秒就会更新一次微服务实例的清单，只要发现有超过90秒没有完成续约的实例，就会将其剔除出去

- 自我保护

  在Eureka注册之后，它自己也会通过心跳来告诉自己还活着。在Eureka运行期间，如果在15分钟内低于85%的情况下心跳测试失败，它就会出现警告（在单机测试中很容易出现，在实际生产环境中往往是网络故障），当然可以通过配置来修改为false 

  只是这样会存在一定的风险，在大部分情况下，只需要采用默认值true就好，不需要对其进行修改。在本机的测试中，一般会将其配置为false，以避免发生关闭的微服务实例无法被服务治理中心剔除出去的问题

####  微服务之间的相互调用

- 服务获取

  服务获取是指微服务实例作为Eureka的客户端，从Eureka服务治理中心获取其他微服务实例清单的功能。它还会将该服务实例清单缓存到本地，并且按一定的时间间隔刷新。当我们启动微服务实例的时候，它就会以一个时间间隔（默认是30秒）向Eureka服务治理中心发送REST风格请求，获取一份只读的服务实例清单，跟着进行缓存，在下一个时间间隔再发送REST风格请求到Eureka，获取最新的服务实例清单，以确定哪些实例可用，哪些实例不可用

- 服务调用
  服务调用是指一个微服务调用另一个微服务的过程。在SpringCloud中，大部分会采用REST风格请求。一个微服务下存在多个实例，那么会采用哪个实例呢？首先，我们之前谈过服务获取的功能，它会从Eureka服务治理中心拉取一份服务实例清单，然后通过某种负载均衡的算法，选择具体的实例，所以这里服务调用的过程核心往往就是负载均衡的算法了。这里我们把它称为“客户端负载均衡”，请注意，这里的“客户端”是针对Eureka服务中心而言的，也就是微服务实例自身是Eureka的客户端。这里的负载均衡是一个相当复杂的内容，在未来我们谈到Ribbon时才会详细地讨



