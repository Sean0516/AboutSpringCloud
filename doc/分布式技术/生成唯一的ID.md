### 使用数据库自增ID生成ID

通过设置数据库的主键初始化值和设置数据库主键增长的步长来生成ID



使用数据库自增ID 会带来以下问题

1. 如果需要增加数据库节点，就要改变自增规则，这样不利于扩展
2. 如果出现高并发场景，数据库的性能可能无法满足需求，这时优化数据库会变得十分复杂。 优化的空间也很有限
3. 如果数据需要迁移或者合并。需要考虑现有规则和新规则的适应性



### SnowFlake算法

​	关于SnowFlake算法对于64位二进制的约定，这里结合图13-5做更为详细的阐述

1. 第1位二进制值固定为0，没有业务含义，在计算机原理中，它是一个符号位，0代表正数，1代表负数，这里恒定为0。
2. 第2～42位，共41位二进制，为时间戳位，用于存入精确到毫秒数的时间。
3. 第43～52位，共10位二进制，为工作机器id位，其中工作机器又分为5位数据中心编号和5位受理机器编号，而5位二进制表达整数时取值区间为[0, 31]。
4. 第53～64位，共12位二进制，代表1ms内可以产生的序列号，当它表示整数时，取值区间为[0, 4095]

我们可以看到，这样的一个算法可以保证在1ms内生成4096个编号，实际就是1秒至多产生4096000个ID，这样的性能显然可以满足分布式系统的需要，而更加好的是，存在10位工作机器位，这样出现问题可以定位到机器，有助于业务和开发者定位问题。但是这里需要特别指出的是，由于当前分布式和微服务系统都开始了去中心化，也就是业务数据不再和具体的机器绑定，因此受理机器编号当前使用已经不多了，所以本书的Snowflake算法也将不再考虑受理机器编号的问题

SnowFlake算法是一种高效的算法，每秒可以产生数十万的ID，它包含了数据中心（旧算法在不去中心化的情况下还可以包含受理机器编号）、时间戳和序号3种业务逻辑，可以在一定的程度上帮助我们定位业务。由于性能好且带有一定的业务数据，因此受到了许多互联网企业的青睐，使用得也比较广泛

但是这个算法也有一些缺陷

1. 因为时间戳只存在41位二进制，所以只能使用69年，69年后就可能产生重复的ID了，不过这个时间已经比较长了，相信大部分的系统和主要的算法早已更替
2. 从SnowFlake算法上来看，如果机器性能足够好，每秒可以产生超过400万个ID，但是对于大部分企业来说，只需要每秒满足数万个ID即可，并不需要这么高的性能。这种高性能浪费的主要是序号的二进制位，实际上，二进制位达到9位，就可以产生512个序号，如果机器性能足够，就可以每秒产生超过50万的ID，这就已经能满足大部分企业的需要了
3. 从机器位来说，因为去中心化是分布式和微服务的趋势，所以我在实现的时候，并未考虑受理机器编号，这样就会造成机器位数有10位二进制，可以表达区间[0, 1023]的整数。如果数据中心预估总共只有几十台机器，显然也会造成二进制位的浪费

